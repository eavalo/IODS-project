# Clustering and classification

```{r message=FALSE}
# Load libraries
library(corrplot)
library(dplyr)
```


## Data

Load in the **Boston** dataset from the MASS package.

```{r data_reading_e4, message=FALSE}
library(MASS)
data("Boston")
str(Boston)
```
The dataset has 14 variables and 506 observations. The following variables are present:

* *crim* - per capita crime rate by town.
* *zn* - proportion of residential land zoned for lots over 25,000 sq.ft.
* *indus* - proportion of non-retail business acres per town.
* *chas* - Charles River dummy variable (= 1 if tract bounds river; 0 otherwise).
* *nox* - nitrogen oxides concentration (parts per 10 million).
* *rm* - average number of rooms per dwelling.
* *age* - proportion of owner-occupied units built prior to 1940.
* *dis* - weighted mean of distances to five Boston employment centres.
* *rad* - index of accessibility to radial highways.
* *tax* - full-value property-tax rate per \$10,000.
* *ptratio* - pupil-teacher ratio by town.
* *black* - 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town.
* *lstat* - lower status of the population (percent).
* *medv* - median value of owner-occupied homes in $1000s.


More details of the dataset can be found here https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/Boston.html.

## Data exploration

Summary of the variabes in the dataset:
```{r}
summary(Boston)
```

Explore the distribution of the variables by plotting:
```{r exploratory_plots_4, fig.height=12, fig.width=12, warning=F, message=F}
library(GGally)
library(ggplot2)

# Define the plot.
p <- ggpairs(Boston, mapping = aes(alpha=0.3), 
             lower = list(combo = wrap("facethist", bins = 20)), legend=1)

# Draw the plot
p

```

Correlation of the variables:
```{r}
cor(Boston) %>% corrplot(method="circle", type="upper", cl.pos="b", tl.pos="d")
```

## Data wrangling

Scale the dataset so that the mean of each variable is zero and standard deviation is one:

$$x_{scaled}=\frac{x - \mu_{x}}{\sigma_{x}}$$,

where $\mu_{x}$ is the mean of x and $\sigma_{x}$ the standard deviation of x.

```{r}
boston_scaled <- scale(Boston) %>% as.data.frame()
summary(boston_scaled)
```

From the summary we can see that the mean of the scaled variables is zero.

Create a factor variable *cr√≠me* from the *crim* (per capita crime rate by town) by dividing the *crim* variable by quartiles to 'low', 'med_low', 'med_high' and 'high' categories:

```{r}
# Create a quantile vector of crim and print it
bins <- quantile(boston_scaled$crim)

# Create a categorical variable 'crime'
crime <- cut(boston_scaled$crim, breaks = bins, include.lowest = TRUE, 
             label=c("low", "med_low", "med_high", "high"))

# Remove original crim from the dataset
boston_scaled <- dplyr::select(boston_scaled, -crim)

# Add the new categorical value to scaled data
boston_scaled <- data.frame(boston_scaled, crime)
```

Divide the dataset to training and test sets so that 80% belongs to the training set and 20% belongs to the test set.

```{r}
# Set seed so the results are reproducible
set.seed(1234)
# Take randomly 80% of the observations to the training set
train.idx <- sample(nrow(boston_scaled), size = 0.8 * nrow(boston_scaled))
train <- boston_scaled[train.idx,]
# Take the remaining 20% to the test set
test <- boston_scaled[-train.idx,]
```

## Linear discriminant analysis
Fit the linear discriminant analysis (LDA) on the training set using the categorical crime rate as the target variable and all the other variables in the dataset as predictor variables.

```{r}
# linear discriminant analysis
lda.fit <- lda(crime ~ ., data = train)
```

The LDA biplot:
```{r}
# the function for lda biplot arrows
lda.arrows <- function(x, myscale = 1, arrow_heads = 0.1, color = "red", tex = 0.75, choices = c(1,2)){
  heads <- coef(x)
  arrows(x0 = 0, y0 = 0, 
         x1 = myscale * heads[,choices[1]], 
         y1 = myscale * heads[,choices[2]], col=color, length = arrow_heads)
  text(myscale * heads[,choices], labels = row.names(heads), 
       cex = tex, col=color, pos=3)
}

# target classes as numeric
classes <- as.numeric(train$crime)

# plot the lda results
plot(lda.fit, dimen = 2, col=classes, pch=classes)
lda.arrows(lda.fit, myscale = 2)
```

Use the fitted LDA model to predict the categorical crime rate in the test set. Cross tabulate the observed classes and the predicted classes in the test set:
```{r}
# Save the correct classes from test data
correct_classes <- test$crime

# Remove the crime variable from test data
test <- dplyr::select(test, -crime)

# predict classes with test data
lda.pred <- predict(lda.fit, newdata = test)

# cross tabulate the results
table(correct = correct_classes, predicted = lda.pred$class)
```

Model seems to perform perfectly at predicting the 'high' class and also predicts the other classes reasonably well. The prediction accuracy is worst for the 'low' class. The model mis-classifies a big proportion of the 'low' observations as 'med_low'.
